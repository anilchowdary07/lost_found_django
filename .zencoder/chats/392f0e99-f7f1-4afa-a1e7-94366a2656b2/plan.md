# Feature development workflow

---

## Workflow Steps

### [x] Step: Requirements

Your job is to generate a Product Requirements Document based on the feature description,

First, analyze the provided feature definition and determine unclear aspects. For unclear aspects: - Make informed guesses based on context and industry standards - Only mark with [NEEDS CLARIFICATION: specific question] if: - The choice significantly impacts feature scope or user experience - Multiple reasonable interpretations exist with different implications - No reasonable default exists - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details

Ask up to 5 most priority clarifications to the user. Then, create the document following this template:

```
# Feature Specification: [FEATURE NAME]


## User Stories*


### User Story 1 - [Brief Title]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

## Requirements*

## Success Criteria*

```

Save the PRD into `/Users/anilchowdary/Documents/lost_found/.zencoder/chats/392f0e99-f7f1-4afa-a1e7-94366a2656b2/requirements.md`.

### [x] Step: Technical Specification

Based on the PRD in `/Users/anilchowdary/Documents/lost_found/.zencoder/chats/392f0e99-f7f1-4afa-a1e7-94366a2656b2/requirements.md`, create a detailed technical specification to be used by a coding agent to implement the feature. Follow this template:

```
# Technical Specification: [FEATURE]

## Technical Context
Language/Version, primary dependencies, etc

## Technical Implementation Brief

Summarize key technical decisions for implementing the feature. Make sure they take into account the existing code as much as possible.

## Source Code Structure

## Contracts

Define addition or changes in data models, DB schemas, APIs, code interfaces etc

## Delivery Phases

Define several incremental deliverables for the feature. Each should be a minimal viable product testable end-to-end.

## Verification Strategy

Define how the coding agent can verify each deliverable it creates. Provide instructions for the agent to perform the verification using available tools (lint/test commands, bash commands) and create helper scripts and tools for more complex result verification.
The verification for each deliverable should be executable by a coding agent using built-in capabilities (lint and test commands from the project, bash commands), pre-generated helper scripts or MCP servers. Research and add to the spec:

- MCP servers that should be installed to help the agent with the verification

- helper scripts that need to be generated in the first phases of the plan to verify complex scenarios that can't be covered by the tests in the project's test framework(s)

- any sample input artifact(s) that are required for verification. Note if these artifacts can be a) generated by the agent; b) discovered by the agent on line; c) must be provided by the user.
```

Save the spec to `/Users/anilchowdary/Documents/lost_found/.zencoder/chats/392f0e99-f7f1-4afa-a1e7-94366a2656b2/spec.md`.

### [ ] Step: Implementation Plan

Based on the technical spec in `/Users/anilchowdary/Documents/lost_found/.zencoder/chats/392f0e99-f7f1-4afa-a1e7-94366a2656b2/spec.md`, create a detailed task plan and update `/Users/anilchowdary/Documents/lost_found/.zencoder/chats/392f0e99-f7f1-4afa-a1e7-94366a2656b2/plan.md`. Each task should have task definition, references to contracts to be used/implemented, deliverable definition and verification instructions.

Format each task as

```
### [ ] Step: <task_name>
Task instructions
```

---

## Implementation Tasks

### [x] Phase 1: Project Setup & Core Models

**Task**: Initialize Django project, create models (Item, Claim, Notification), configure Cloudinary and Gemini APIs, run migrations.

**Contracts Used**: User (Django built-in), Item, Claim, Notification models from spec.md

**Deliverable**: Django app with models in SQLite, database ready for data insertion

**Verification Instructions**:
1. Run `python manage.py migrate` → all migrations apply successfully
2. Access Django admin at `http://localhost:8000/admin/` → can see Item, Claim, Notification models
3. Run `python manage.py shell` and verify models import: `from items.models import Item, Claim, Notification`

---

### [x] Phase 2: User Authentication (Signup/Login/Logout)

**Task**: Create signup form, login form, logout view. Set up login_required decorators. Create base template with navbar showing logged-in user.

**Contracts Used**: User (Django built-in), login/signup views from spec.md

**Deliverable**: Users can register, log in, log out; session persists; navbar shows user info

**Verification Instructions**:
1. Navigate to `/accounts/signup/` → see signup form, create test account
2. Log in with created credentials → navbar shows username, redirected to dashboard
3. Click logout → session cleared, redirected to home
4. Try accessing `/items/create/` without login → redirected to login page

---

### [x] Phase 3: Report Found Item + Gemini Integration

**Task**: Create Item creation form with image upload. Implement `process_image_with_gemini()` function. Create AJAX endpoint for Gemini processing. Frontend shows AI-suggested tags (editable) before submission.

**Contracts Used**: Item model, Gemini API endpoint, image upload to Cloudinary

**Deliverable**: Users upload image → see AI tags within 5 seconds → edit tags → submit item

**Verification Instructions**:
1. Log in, navigate to `/items/create/`
2. Upload test image (laptop, backpack, etc.)
3. Verify tags/category appear within 5 seconds
4. Edit a tag (remove/add custom), submit
5. Check item appears on dashboard with correct tags
6. Verify image URL is Cloudinary URL (not local)

---

### [x] Phase 4: Dashboard with Search & Filter

**Task**: Create dashboard view displaying all items as Bootstrap cards. Implement search (title + tags) and category filter. Add responsive grid layout (1 col mobile, 2 tablet, 3+ desktop).

**Contracts Used**: Item model, Search/Filter API endpoints, Bootstrap 5

**Deliverable**: Homepage displays items, searchable by keyword and filterable by category, responsive

**Verification Instructions**:
1. Create 5+ test items with varied categories
2. On `/items/` verify all items display as cards
3. Search "backpack" → results filter correctly
4. Filter by "Electronics" → shows only Electronics
5. Resize browser (mobile/tablet/desktop) → layout adapts correctly
6. Verify "Claim" button visible on each card

---

### [x] Phase 5: Claim & Notification System

**Task**: Create Claim model and claim submission endpoint. Create Notification model and auto-trigger on claim. Create notifications page with "Reveal Contact" button that shows claimer email.

**Contracts Used**: Claim, Notification models, Claim creation endpoint, Reveal Contact endpoint

**Deliverable**: Users claim items → finder receives notification → contact revealed on demand

**Verification Instructions**:
1. Log in as User A, create found item "Red Backpack"
2. Log in as User B (incognito), claim the item with message
3. Switch to User A, navigate to `/notifications/`
4. See claim notification from User B
5. Click "Reveal Contact" → see User B's email
6. Verify item status changed to "Claimed" on dashboard

---

### [ ] Phase 6: Testing & Polish

**Task**: Add form validation, error handling, user feedback (toast messages). Write E2E tests (signup → report → claim → notification flow). Test with multiple image types. Verify responsive design. Test Cloudinary + Gemini integration.

**Contracts Used**: All models and views from Phases 1-5, E2E test framework (Playwright)

**Deliverable**: All features working end-to-end, tested, production-ready

**Verification Instructions**:
1. Run full E2E test suite (Playwright): `playwright test`
2. Test with various image types (JPG, PNG, WebP)
3. Test form validation (missing fields, invalid image)
4. Manual smoke test on mobile device or browser dev tools
5. Verify all links work, no 404s or 500s
6. Check console for JavaScript errors
7. Confirm Cloudinary URLs load images correctly
